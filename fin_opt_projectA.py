import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns

# Import PyPortfolioOpt
try:
    from pypfopt import EfficientFrontier, risk_models, expected_returns
    from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices
except ImportError:
    print("‚ùå C√†i ƒë·∫∑t: pip install PyPortfolioOpt")
    raise

import ipywidgets as widgets
from IPython.display import display, clear_output
import warnings
warnings.filterwarnings('ignore')

# Thi·∫øt l·∫≠p style
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 10

class DataFetcher:
    """L·∫•y d·ªØ li·ªáu c·ªï phi·∫øu t·ª´ nhi·ªÅu ngu·ªìn"""
    
    @staticmethod
    def get_vn_stock(symbol, start_date, end_date):
        """L·∫•y d·ªØ li·ªáu VN t·ª´ nhi·ªÅu ngu·ªìn"""
        start_str = start_date.strftime('%Y-%m-%d')
        end_str = end_date.strftime('%Y-%m-%d')
        
        # Ph∆∞∆°ng ph√°p 1: Th·ª≠ vnstock3 (phi√™n b·∫£n m·ªõi)
        try:
            from vnstock3 import Vnstock
            stock = Vnstock().stock(symbol=symbol, source='VCI')
            df = stock.quote.history(start=start_str, end=end_str)
            
            if df is not None and not df.empty:
                if 'time' in df.columns:
                    df.index = pd.to_datetime(df['time'])
                if 'close' in df.columns:
                    df['Adj Close'] = df['close']
                elif 'Close' in df.columns:
                    df['Adj Close'] = df['Close']
                
                if 'Adj Close' in df.columns:
                    result = df[['Adj Close']]
                    # Lo·∫°i b·ªè duplicate index
                    result = result[~result.index.duplicated(keep='last')]
                    return result
        except ImportError:
            pass
        except Exception as e:
            pass
        
        # Ph∆∞∆°ng ph√°p 2: Th·ª≠ vnstock (phi√™n b·∫£n c≈©)
        try:
            from vnstock import stock_historical_data
            
            df = stock_historical_data(
                symbol=symbol,
                start_date=start_str,
                end_date=end_str,
                resolution='1D',
                type='stock'
            )
            
            if df is not None and not df.empty:
                if 'time' in df.columns:
                    df.index = pd.to_datetime(df['time'])
                elif 'TradingDate' in df.columns:
                    df.index = pd.to_datetime(df['TradingDate'])
                
                if 'close' in df.columns:
                    df['Adj Close'] = df['close']
                elif 'Close' in df.columns:
                    df['Adj Close'] = df['Close']
                
                if 'Adj Close' in df.columns:
                    result = df[['Adj Close']]
                    # Lo·∫°i b·ªè duplicate index
                    result = result[~result.index.duplicated(keep='last')]
                    return result
        except Exception as e:
            pass
        
        # Ph∆∞∆°ng ph√°p 3: Th·ª≠ yfinance v·ªõi .VN suffix
        try:
            import pandas_datareader as pdr
            vn_symbol = f"{symbol}.VN"
            df = pdr.get_data_yahoo(vn_symbol, start=start_date, end=end_date)
            if df is not None and not df.empty and 'Adj Close' in df.columns:
                result = df[['Adj Close']]
                # Lo·∫°i b·ªè duplicate index
                result = result[~result.index.duplicated(keep='last')]
                return result
        except Exception as e:
            pass
        
        # Ph∆∞∆°ng ph√°p 4: Th·ª≠ v·ªõi SSI API (n·∫øu c√≥)
        try:
            from vnstock import stock_historical_data
            
            # Th·ª≠ v·ªõi type='index' cho ETF
            df = stock_historical_data(
                symbol=symbol,
                start_date=start_str,
                end_date=end_str,
                resolution='1D',
                type='index'
            )
            
            if df is not None and not df.empty:
                if 'time' in df.columns:
                    df.index = pd.to_datetime(df['time'])
                if 'close' in df.columns:
                    df['Adj Close'] = df['close']
                elif 'Close' in df.columns:
                    df['Adj Close'] = df['Close']
                
                if 'Adj Close' in df.columns:
                    result = df[['Adj Close']]
                    # Lo·∫°i b·ªè duplicate index
                    result = result[~result.index.duplicated(keep='last')]
                    return result
        except Exception as e:
            pass
        
        return None
    
    @staticmethod
    def get_us_stock(symbol, start_date, end_date):
        """L·∫•y d·ªØ li·ªáu US t·ª´ pandas-datareader"""
        try:
            import pandas_datareader as pdr
            df = pdr.get_data_yahoo(symbol, start=start_date, end=end_date)
            if df is not None and not df.empty and 'Adj Close' in df.columns:
                result = df[['Adj Close']]
                # Lo·∫°i b·ªè duplicate index
                result = result[~result.index.duplicated(keep='last')]
                return result
        except ImportError:
            print(f"‚ö†Ô∏è C√†i ƒë·∫∑t: pip install pandas-datareader")
            return None
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói {symbol}: {str(e)}")
            return None

class PortfolioOptimizer:
    def __init__(self):
        self.df = None
        self.weights = None
        self.performance = None
        
        self.vn_stocks = ['E1VFVN30', 'FUEVFVND', 'FUESSV30', 'FUESSVFL', 'VNM', 'VIC', 
                          'VHM', 'GAS', 'MSN', 'HPG', 'TCB', 'MBB', 'VCB', 'BID', 
                          'CTG', 'FPT', 'MWG', 'VRE', 'PLX', 'GVR']
        
        self.risk_profiles = {
            'B·∫£o th·ªß': {
                'description': '∆Øu ti√™n b·∫£o to√†n v·ªën',
                'max_volatility': 0.12,
                'color': '#4CAF50'
            },
            'Trung b√¨nh': {
                'description': 'C√¢n b·∫±ng r·ªßi ro v√† l·ª£i nhu·∫≠n',
                'max_volatility': 0.15,
                'color': '#FFC107'
            },
            'T√≠ch c·ª±c': {
                'description': 'Ch·∫•p nh·∫≠n r·ªßi ro cao',
                'max_volatility': 0.20,
                'color': '#FF9800'
            },
        }
        
        self.create_widgets()
    
    def detect_market(self, symbol):
        """X√°c ƒë·ªãnh th·ªã tr∆∞·ªùng (VN hay US)"""
        if symbol in self.vn_stocks or '.VN' in symbol:
            return 'VN'
        return 'US'
    
    def fetch_data(self, symbols, start_date, end_date):
        """L·∫•y d·ªØ li·ªáu t·ª´ nhi·ªÅu ngu·ªìn"""
        all_data = {}
        failed_symbols = []
        
        for symbol in symbols:
            market = self.detect_market(symbol)
            clean_symbol = symbol.replace('.VN', '')
            
            print(f"  ‚Ä¢ {clean_symbol}...", end=' ', flush=True)
            
            if market == 'VN':
                df = DataFetcher.get_vn_stock(clean_symbol, start_date, end_date)
            else:
                df = DataFetcher.get_us_stock(clean_symbol, start_date, end_date)
            
            if df is not None and not df.empty:
                # ƒê·∫£m b·∫£o kh√¥ng c√≥ duplicate index
                if df.index.duplicated().any():
                    print(f"(lo·∫°i b·ªè {df.index.duplicated().sum()} ng√†y tr√πng)...", end=' ')
                    df = df[~df.index.duplicated(keep='last')]
                
                all_data[symbol] = df['Adj Close']
                print(f"‚úì ({len(df)} ng√†y)")
            else:
                print("‚úó")
                failed_symbols.append(clean_symbol)
        
        if failed_symbols:
            print(f"\n‚ö†Ô∏è  Kh√¥ng t·∫£i ƒë∆∞·ª£c: {', '.join(failed_symbols)}")
            print(f"üí° Ki·ªÉm tra l·∫°i m√£ ho·∫∑c th·ª≠:")
            print(f"   - Th√™m .VN (VD: {failed_symbols[0]}.VN)")
            print(f"   - Ki·ªÉm tra tr√™n: https://www.vndirect.com.vn")
        
        if all_data:
            # T·∫°o DataFrame v√† ƒë·∫£m b·∫£o index kh√¥ng tr√πng
            combined_df = pd.DataFrame(all_data)
            
            # Lo·∫°i b·ªè duplicate index trong DataFrame t·ªïng h·ª£p
            if combined_df.index.duplicated().any():
                print(f"\nüîß Ph√°t hi·ªán {combined_df.index.duplicated().sum()} ng√†y tr√πng trong d·ªØ li·ªáu t·ªïng h·ª£p, ƒëang x·ª≠ l√Ω...")
                combined_df = combined_df[~combined_df.index.duplicated(keep='last')]
            
            return combined_df
        return None
    
    def clean_data(self, data):
        """L√†m s·∫°ch v√† x·ª≠ l√Ω d·ªØ li·ªáu"""
        # Lo·∫°i b·ªè duplicate index ngay t·ª´ ƒë·∫ßu
        if data.index.duplicated().any():
            print(f"  üîß Lo·∫°i b·ªè {data.index.duplicated().sum()} ng√†y tr√πng l·∫∑p...")
            data = data[~data.index.duplicated(keep='last')]
        
        # Lo·∫°i b·ªè c·ªôt c√≥ qu√° nhi·ªÅu NaN
        min_data_points = int(len(data) * 0.8)
        data = data.dropna(axis=1, thresh=min_data_points)
        
        # Forward fill, backward fill
        data = data.fillna(method='ffill').fillna(method='bfill')
        
        # Lo·∫°i b·ªè c√°c h√†ng c√≤n NaN
        data = data.dropna()
        
        # Lo·∫°i b·ªè c√°c c·ªôt c√≥ gi√° tr·ªã = 0
        data = data.loc[:, (data != 0).all(axis=0)]
        
        # Lo·∫°i b·ªè c√°c c·ªôt c√≥ gi√° tr·ªã √¢m
        data = data.loc[:, (data > 0).all(axis=0)]
        
        # Ki·ªÉm tra gi√° tr·ªã v√¥ c√πng
        data = data.replace([np.inf, -np.inf], np.nan).dropna()
        
        # Ki·ªÉm tra l·∫°i duplicate sau khi x·ª≠ l√Ω
        if data.index.duplicated().any():
            data = data[~data.index.duplicated(keep='last')]
        
        return data
    
    def optimize_portfolio(self, data):
        """T·ªëi ∆∞u h√≥a danh m·ª•c v·ªõi nhi·ªÅu ph∆∞∆°ng ph√°p fallback"""
        
        mode = self.allocation_mode.value
        n_assets = len(data.columns)
        
        # Ch·∫ø ƒë·ªô ph√¢n b·ªï ƒë·ªÅu
        if mode == 'equal':
            print("  Ch·∫ø ƒë·ªô: Ph√¢n b·ªï ƒë·ªÅu")
            weights = {col: 1/n_assets for col in data.columns}
            
            # T√≠nh hi·ªáu su·∫•t
            returns = data.pct_change().dropna()
            portfolio_return = np.sum(returns.mean() * np.array(list(weights.values()))) * 252
            portfolio_std = np.sqrt(np.dot(np.array(list(weights.values())).T, 
                                           np.dot(returns.cov() * 252, 
                                                  np.array(list(weights.values())))))
            sharpe = portfolio_return / portfolio_std if portfolio_std > 0 else 0
            
            performance = (portfolio_return, portfolio_std, sharpe)
            return weights, performance, "Equal Weight (ƒê·ªÅu nhau)"
        
        # X√°c ƒë·ªãnh r√†ng bu·ªôc t·ª∑ tr·ªçng
        if mode == 'min5':
            weight_bounds = (0.05, 1.0)
            mode_desc = "T·ªëi ∆∞u (min 5%)"
        elif mode == 'min10':
            weight_bounds = (0.10, 1.0)
            mode_desc = "T·ªëi ∆∞u (min 10%)"
        else:  # optimal
            weight_bounds = (0, 1.0)
            mode_desc = "T·ªëi ∆∞u (cho ph√©p 0%)"
        
        # Ph∆∞∆°ng ph√°p 1: Min Volatility v·ªõi r√†ng bu·ªôc
        try:
            print(f"  Th·ª≠ ph∆∞∆°ng ph√°p 1: Min Volatility ({mode_desc})...")
            mu = expected_returns.mean_historical_return(data)
            S = risk_models.sample_cov(data)
            
            # Th√™m regularization cho ma tr·∫≠n hi·ªáp ph∆∞∆°ng sai
            S_regularized = S + np.eye(len(S)) * 0.001
            
            ef = EfficientFrontier(mu, S_regularized, weight_bounds=weight_bounds)
            weights = ef.min_volatility()
            cleaned_weights = ef.clean_weights()
            performance = ef.portfolio_performance(verbose=False)
            
            return cleaned_weights, performance, f"Min Volatility ({mode_desc})"
        except Exception as e:
            print(f"    ‚úó Th·∫•t b·∫°i: {e}")
        
        # Ph∆∞∆°ng ph√°p 2: Max Sharpe v·ªõi constraints l·ªèng h∆°n
        try:
            print(f"  Th·ª≠ ph∆∞∆°ng ph√°p 2: Max Sharpe ({mode_desc})...")
            mu = expected_returns.mean_historical_return(data)
            S = risk_models.sample_cov(data)
            S_regularized = S + np.eye(len(S)) * 0.001
            
            ef = EfficientFrontier(mu, S_regularized, weight_bounds=weight_bounds)
            weights = ef.max_sharpe()
            cleaned_weights = ef.clean_weights()
            performance = ef.portfolio_performance(verbose=False)
            
            return cleaned_weights, performance, f"Max Sharpe ({mode_desc})"
        except Exception as e:
            print(f"    ‚úó Th·∫•t b·∫°i: {e}")
        
        # Ph∆∞∆°ng ph√°p 3: N·∫øu c√≥ r√†ng bu·ªôc min%, th·ª≠ l·∫°i v·ªõi (0, 1)
        if mode in ['min5', 'min10']:
            try:
                print("  Th·ª≠ ph∆∞∆°ng ph√°p 3: T·ªëi ∆∞u kh√¥ng r√†ng bu·ªôc...")
                mu = expected_returns.mean_historical_return(data)
                S = risk_models.sample_cov(data)
                S_regularized = S + np.eye(len(S)) * 0.001
                
                ef = EfficientFrontier(mu, S_regularized, weight_bounds=(0, 1))
                weights = ef.min_volatility()
                cleaned_weights = ef.clean_weights()
                performance = ef.portfolio_performance(verbose=False)
                
                return cleaned_weights, performance, "Min Volatility (T·ªëi ∆∞u)"
            except Exception as e:
                print(f"    ‚úó Th·∫•t b·∫°i: {e}")
        
        # Ph∆∞∆°ng ph√°p 4: Equal Weighting (fallback cu·ªëi c√πng)
        try:
            print("  Th·ª≠ ph∆∞∆°ng ph√°p 4: Equal Weighting...")
            weights = {col: 1/n_assets for col in data.columns}
            
            # T√≠nh hi·ªáu su·∫•t
            returns = data.pct_change().dropna()
            portfolio_return = np.sum(returns.mean() * np.array(list(weights.values()))) * 252
            portfolio_std = np.sqrt(np.dot(np.array(list(weights.values())).T, 
                                           np.dot(returns.cov() * 252, 
                                                  np.array(list(weights.values())))))
            sharpe = portfolio_return / portfolio_std if portfolio_std > 0 else 0
            
            performance = (portfolio_return, portfolio_std, sharpe)
            
            return weights, performance, "Equal Weight (ƒê·ªÅu nhau)"
        except Exception as e:
            print(f"    ‚úó Th·∫•t b·∫°i: {e}")
            raise
    
    def create_widgets(self):
        """T·∫°o giao di·ªán"""
        self.header = widgets.HTML(
            value=f"""
            <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                        padding: 30px; border-radius: 15px; margin-bottom: 20px;'>
                <h1 style='color: white; text-align: center; margin: 0;'>
                    üíº PH√ÇN B·ªî ƒê·∫¶U T∆Ø T·ªêI ∆ØU
                </h1>
                <p style='color: white; text-align: center; margin-top: 10px;'>
                    VN & International Markets | {datetime.now().strftime('%d/%m/%Y')}
                </p>
            </div>
            """
        )
        
        self.risk_profile = widgets.Dropdown(
            options=list(self.risk_profiles.keys()),
            value='Trung b√¨nh',
            description='R·ªßi ro:',
            style={'description_width': '100px'}
        )
        
        self.allocation_mode = widgets.Dropdown(
            options=[
                ('T·ªëi ∆∞u (cho ph√©p 0%)', 'optimal'),
                ('Ph√¢n b·ªï ƒë·ªÅu', 'equal'),
                ('T·ªëi thi·ªÉu 5% m·ªói m√£', 'min5'),
                ('T·ªëi thi·ªÉu 10% m·ªói m√£', 'min10')
            ],
            value='optimal',
            description='Ch·∫ø ƒë·ªô:',
            style={'description_width': '100px'}
        )
        
        self.funds_input = widgets.Textarea(
            value='VNM, VIC, GAS',
            placeholder='Nh·∫≠p m√£, c√°ch nhau b·ªüi d·∫•u ph·∫©y\nVD: VNM, VIC, GAS ho·∫∑c SPY, QQQ, BND',
            description='Danh m·ª•c:',
            layout=widgets.Layout(width='80%', height='100px')
        )
        
        self.years_back = widgets.IntSlider(
            value=2, min=1, max=5,
            description='S·ªë nƒÉm:',
            style={'description_width': '100px'}
        )
        
        self.total_capital = widgets.FloatText(
            value=100000000,
            description='V·ªën (VNƒê):',
            style={'description_width': '100px'}
        )
        
        self.analyze_btn = widgets.Button(
            description='üöÄ PH√ÇN T√çCH',
            button_style='success',
            layout=widgets.Layout(width='200px', height='45px')
        )
        self.analyze_btn.on_click(self.run_analysis)
        
        self.output = widgets.Output()
        
        # Th√™m m·∫´u danh m·ª•c
        sample_portfolios = widgets.HTML(
            value="""
            <div style='background: #f5f5f5; padding: 15px; border-radius: 10px; margin: 10px 0;'>
                <b>üìã Danh m·ª•c m·∫´u:</b><br>
                ‚Ä¢ VN Bluechips: VNM, VIC, VHM, GAS, HPG<br>
                ‚Ä¢ VN ETF: E1VFVN30, FUEVFVND, FUESSV30<br>
                ‚Ä¢ VN Tech: FPT, MWG<br>
                ‚Ä¢ US Index: SPY, QQQ, DIA, BND<br>
                ‚Ä¢ Balanced: SPY, BND, GLD, VNM, GAS<br><br>
                <b>üí° Ch·∫ø ƒë·ªô ph√¢n b·ªï:</b><br>
                ‚Ä¢ <b>T·ªëi ∆∞u (0%):</b> Thu·∫≠t to√°n ch·ªçn m√£ t·ªët nh·∫•t, lo·∫°i m√£ k√©m<br>
                ‚Ä¢ <b>Ph√¢n b·ªï ƒë·ªÅu:</b> Chia ƒë·ªÅu 10 m√£ = 10% m·ªói m√£<br>
                ‚Ä¢ <b>T·ªëi thi·ªÉu 5-10%:</b> M·ªói m√£ √≠t nh·∫•t 5-10%, c√≤n l·∫°i t·ªëi ∆∞u
            </div>
            """
        )
        
        input_box = widgets.VBox([
            widgets.HTML("<h2>üéØ THI·∫æT L·∫¨P DANH M·ª§C</h2>"),
            sample_portfolios,
            self.risk_profile,
            self.allocation_mode,
            self.funds_input,
            self.years_back,
            self.total_capital,
            self.analyze_btn,
            self.output
        ])
        
        self.tabs = widgets.Tab()
        self.analysis_output = widgets.Output()
        
        self.tabs.children = [input_box, self.analysis_output]
        self.tabs.set_title(0, 'üéØ Thi·∫øt L·∫≠p')
        self.tabs.set_title(1, 'üìä Ph√¢n T√≠ch')
    
    def run_analysis(self, b):
        """Ch·∫°y ph√¢n t√≠ch"""
        with self.output:
            clear_output()
            print("üîÑ ƒêang ph√¢n t√≠ch...")
        
        try:
            funds = [f.strip().upper() for f in self.funds_input.value.split(',') if f.strip()]
            
            if len(funds) < 2:
                with self.output:
                    clear_output()
                    print("‚ùå C·∫ßn √≠t nh·∫•t 2 m√£!")
                return
            
            end_date = datetime.now()
            start_date = end_date - timedelta(days=365 * self.years_back.value)
            
            with self.output:
                clear_output()
                print("üì• ƒêang t·∫£i d·ªØ li·ªáu...\n")
            
            data = self.fetch_data(funds, start_date, end_date)
            
            if data is None or data.empty:
                with self.output:
                    clear_output()
                    print("‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu!")
                return
            
            with self.output:
                print(f"\n‚úÖ T·∫£i ƒë∆∞·ª£c {len(data.columns)} t√†i s·∫£n, {len(data)} ng√†y")
                print("üßπ ƒêang l√†m s·∫°ch d·ªØ li·ªáu...")
            
            data = self.clean_data(data)
            
            if len(data) < 60:
                with self.output:
                    clear_output()
                    print(f"‚ùå Ch·ªâ c√≥ {len(data)} ng√†y h·ª£p l·ªá (c·∫ßn >60)")
                return
            
            if len(data.columns) < 2:
                with self.output:
                    clear_output()
                    print("‚ùå Kh√¥ng ƒë·ªß t√†i s·∫£n h·ª£p l·ªá sau khi l√†m s·∫°ch!")
                return
            
            self.df = data
            
            with self.output:
                print(f"‚úÖ D·ªØ li·ªáu s·∫°ch: {len(data.columns)} t√†i s·∫£n, {len(data)} ng√†y")
                print("‚è≥ ƒêang t·ªëi ∆∞u danh m·ª•c...")
            
            # T·ªëi ∆∞u danh m·ª•c
            weights, performance, method = self.optimize_portfolio(data)
            
            self.weights = weights
            self.performance = performance
            self.method = method
            
            with self.output:
                print(f"‚úÖ Ho√†n t·∫•t! (Ph∆∞∆°ng ph√°p: {method})")
                print(f"üìà L·ª£i nhu·∫≠n k·ª≥ v·ªçng: {performance[0]*100:.2f}%/nƒÉm")
                print(f"üìä Volatility: {performance[1]*100:.2f}%")
                print(f"‚≠ê Sharpe Ratio: {performance[2]:.2f}")
            
            self.display_analysis()
            self.tabs.selected_index = 1
            
        except Exception as e:
            with self.output:
                clear_output()
                print(f"‚ùå L·ªói: {str(e)}")
                import traceback
                print("\nüìã Chi ti·∫øt l·ªói:")
                print(traceback.format_exc())
    
    def display_analysis(self):
        """Hi·ªÉn th·ªã k·∫øt qu·∫£ ph√¢n t√≠ch"""
        with self.analysis_output:
            clear_output()
            
            print("="*80)
            print(" "*25 + "üìä K·∫æT QU·∫¢ PH√ÇN T√çCH")
            print("="*80)
            
            print(f"\nüìÖ K·ª≥ ph√¢n t√≠ch: {self.df.index[0].strftime('%d/%m/%Y')} ‚Üí {self.df.index[-1].strftime('%d/%m/%Y')}")
            print(f"üíº S·ªë t√†i s·∫£n: {len([w for w in self.weights.values() if w > 0])}/{len(self.df.columns)}")
            print(f"üí∞ V·ªën ƒë·∫ßu t∆∞: {self.total_capital.value:,.0f} VNƒê")
            print(f"üéØ Ph∆∞∆°ng ph√°p: {self.method}")
            
            print("\n" + "="*80)
            print(" "*25 + "üìà HI·ªÜU SU·∫§T K·ª≤ V·ªåNG")
            print("="*80)
            
            expected_return = self.performance[0] * 100
            volatility = self.performance[1] * 100
            sharpe = self.performance[2]
            
            print(f"\n{'üìà L·ª£i nhu·∫≠n k·ª≥ v·ªçng/nƒÉm:':<40} {expected_return:>10.2f}%")
            print(f"{'üìä ƒê·ªô bi·∫øn ƒë·ªông (Volatility):':<40} {volatility:>10.2f}%")
            print(f"{'‚≠ê Sharpe Ratio:':<40} {sharpe:>10.2f}")
            
            if sharpe > 2:
                rating = "‚≠ê‚≠ê‚≠ê Xu·∫•t s·∫Øc"
            elif sharpe > 1:
                rating = "‚≠ê‚≠ê T·ªët"
            elif sharpe > 0.5:
                rating = "‚≠ê Ch·∫•p nh·∫≠n ƒë∆∞·ª£c"
            else:
                rating = "‚ö†Ô∏è C·∫ßn c·∫£i thi·ªán"
            print(f"{'üèÜ ƒê√°nh gi√°:':<40} {rating}")
            
            print("\n" + "="*80)
            print(" "*30 + "üíº T·ª∂ TR·ªåNG")
            print("="*80)
            
            weights_df = pd.DataFrame.from_dict(self.weights, orient='index', columns=['T·ª∑ tr·ªçng'])
            weights_df = weights_df[weights_df['T·ª∑ tr·ªçng'] > 0.001].sort_values('T·ª∑ tr·ªçng', ascending=False)
            weights_df['%'] = (weights_df['T·ª∑ tr·ªçng'] * 100).round(2)
            
            print(f"\n{'M√£':<15} {'T·ª∑ tr·ªçng':<12} {'Bi·ªÉu ƒë·ªì'}")
            print("-"*80)
            
            for idx, row in weights_df.iterrows():
                bar = "‚ñà" * int(row['%'] / 2)
                market = "üáªüá≥" if self.detect_market(idx) == 'VN' else "üåé"
                print(f"{market} {idx:<12} {row['%']:>6.2f}%     {bar}")
            
            print("\n" + "="*80)
            print(f"T·ªïng t·ª∑ tr·ªçng: {weights_df['%'].sum():.2f}%")
            
            self.plot_analysis()
    
    def plot_analysis(self):
        """V·∫Ω bi·ªÉu ƒë·ªì ph√¢n t√≠ch"""
        weights_df = pd.DataFrame.from_dict(self.weights, orient='index', columns=['T·ª∑ tr·ªçng'])
        weights_df = weights_df[weights_df['T·ª∑ tr·ªçng'] > 0.001].sort_values('T·ª∑ tr·ªçng', ascending=False)
        weights_df['%'] = (weights_df['T·ª∑ tr·ªçng'] * 100).round(2)
        
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        
        # Pie chart
        colors = plt.cm.Set3(range(len(weights_df)))
        axes[0, 0].pie(weights_df['%'], labels=weights_df.index, autopct='%1.1f%%', 
                       colors=colors, startangle=90)
        axes[0, 0].set_title('üíº Ph√¢n B·ªï T·ª∑ Tr·ªçng', fontsize=12, fontweight='bold')
        
        # Bar chart
        weights_df.plot(kind='barh', ax=axes[0, 1], color=colors, legend=False, y='%')
        axes[0, 1].set_xlabel('T·ª∑ tr·ªçng (%)')
        axes[0, 1].set_title('üìä Chi Ti·∫øt T·ª∑ Tr·ªçng', fontsize=12, fontweight='bold')
        axes[0, 1].grid(axis='x', alpha=0.3)
        
        # Price history
        normalized = self.df / self.df.iloc[0] * 100
        for col in normalized.columns:
            if col in self.weights and self.weights[col] > 0.001:
                axes[1, 0].plot(normalized.index, normalized[col], label=col, linewidth=2)
        axes[1, 0].set_ylabel('Gi√° chu·∫©n h√≥a (Base=100)')
        axes[1, 0].set_title('üìà L·ªãch S·ª≠ Gi√°', fontsize=12, fontweight='bold')
        axes[1, 0].legend(fontsize=8, loc='best')
        axes[1, 0].grid(alpha=0.3)
        axes[1, 0].axhline(y=100, color='red', linestyle='--', alpha=0.5, linewidth=1)
        
        # Correlation
        selected_cols = [col for col in self.df.columns if col in self.weights and self.weights[col] > 0.001]
        if len(selected_cols) > 1:
            corr = self.df[selected_cols].corr()
            im = axes[1, 1].imshow(corr, cmap='RdYlGn', vmin=-1, vmax=1, aspect='auto')
            axes[1, 1].set_xticks(range(len(corr)))
            axes[1, 1].set_yticks(range(len(corr)))
            axes[1, 1].set_xticklabels(corr.columns, rotation=45, ha='right', fontsize=9)
            axes[1, 1].set_yticklabels(corr.columns, fontsize=9)
            axes[1, 1].set_title('üîó Ma Tr·∫≠n T∆∞∆°ng Quan', fontsize=12, fontweight='bold')
            
            # Th√™m gi√° tr·ªã t∆∞∆°ng quan
            for i in range(len(corr)):
                for j in range(len(corr)):
                    text = axes[1, 1].text(j, i, f'{corr.iloc[i, j]:.2f}',
                                          ha="center", va="center", color="black", fontsize=8)
            
            plt.colorbar(im, ax=axes[1, 1])
        else:
            axes[1, 1].text(0.5, 0.5, 'C·∫ßn >1 t√†i s·∫£n\nƒë·ªÉ hi·ªÉn th·ªã t∆∞∆°ng quan', 
                           ha='center', va='center', fontsize=12)
            axes[1, 1].set_title('üîó Ma Tr·∫≠n T∆∞∆°ng Quan', fontsize=12, fontweight='bold')
        
        plt.tight_layout()
        plt.show()
    
    def display(self):
        """Hi·ªÉn th·ªã giao di·ªán"""
        display(self.header)
        display(self.tabs)

# Kh·ªüi ƒë·ªông
"""
print("="*80)
print(" "*20 + "üöÄ H·ªÜ TH·ªêNG PH√ÇN B·ªî ƒê·∫¶U T∆Ø")
print("="*80)
print("\nüì¶ Y√™u c·∫ßu:")
print("   pip install PyPortfolioOpt ipywidgets pandas-datareader")
print("   pip install vnstock  # (optional, cho c·ªï phi·∫øu VN)")
print("\n‚ú® S·∫µn s√†ng! Python 3.8+ Compatible")
print("="*80 + "\n")
"""
app = PortfolioOptimizer()
app.display()
